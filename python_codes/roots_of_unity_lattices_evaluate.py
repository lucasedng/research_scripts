from numpy import exp, gcd, real, imag
from numpy import array, dot, matrix
from numpy import pi as _pi
from numpy.linalg import det

from sympy.ntheory.factor_ import totient
from itertools import chain
from typing import Union, List


# returns the nth primitive root of the unit
def _nth_roots_of_unity(number: int) -> Union[float, None]:

    argument = (2*_pi*1j)/number

    return (
        exp(argument) if number > 0
        else None
    )


# calculates phi(n)
def _totient_euler_function(number: int) -> int:
    return totient(number)


# returns base of integer rings - integral base
def interger_ring_basis(number: int) -> List[float]:

    base_number = _nth_roots_of_unity(number)
    return [
        base_number**i for i in range(_totient_euler_function(number))
    ]


# applies all homomorphisms to an element x
def _distinct_homomorphisms_applied(number: int, x: float) -> List[float]:

    def _expoents_with_gcd_one(number):
        return [
            expoent for expoent in range(number)
            if gcd(expoent, number) == 1
        ]

    return [
        x**expoent for expoent in _expoents_with_gcd_one(number)
    ]


# returns the non-repeating part of homomorphisms
def _without_conjugate_homomorphisms(number: int, x: float) -> List[float]:
    return _distinct_homomorphisms_applied(number, x)[:_totient_euler_function(number)//2]


# applies minkowski homomorphism to an element
def _minkowski_homomorphism(number: int, x: float) -> List[float]:
    
    real_and_imag_values = [
        [real(element), imag(element)] for element in _without_conjugate_homomorphisms(number, x)
    ]

    return list(chain(*real_and_imag_values))


# returns the base of the lattice generated by minkowski homomorphism
def nth_root_of_unity_lattice_basis(number: int) -> List[List[float]]:
    return [
        _minkowski_homomorphism(number, vector) for vector in interger_ring_basis(number)
    ]


# returns the gram matrix of the lattice
def lattice_gram_matrix(number: int) -> matrix:
    
    generator_matrix = array(nth_root_of_unity_lattice_basis(number))

    return dot(generator_matrix, generator_matrix.transpose())


# does exactly what it says
def evaluate_lattice_determinant(matrix: matrix) -> float: 
    
    return det(matrix)


def main() -> None:

    print(array(nth_root_of_unity_lattice_basis(3)))
    print(lattice_gram_matrix(3))
    print(evaluate_lattice_determinant(lattice_gram_matrix(3)))

    return None


if __name__ == '__main__':
    main()